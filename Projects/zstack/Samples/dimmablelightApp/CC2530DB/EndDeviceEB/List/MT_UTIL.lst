###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.1.10194/W32 for 8051         24/Dec/2025  16:57:44 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  E:\´«¸ÐÆ÷ZStack-CC2530\´«¸ÐÆ÷ZStack-CC2530-ÊµÑµ×îÖ #
#                          Õ°æ±¾\Components\mt\MT_UTIL.c                      #
#    Command line       =  -f E:\´«¸ÐÆ÷ZStack-CC2530\´«¸ÐÆ÷ZStack-CC2530-ÊµÑµ #
#                          ×îÖÕ°æ±¾\Projects\zstack\Samples\dimmablelightApp\ #
#                          CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cfg      #
#                          (-DCPU32MHZ -DROOT=__near_func                     #
#                          -DMAC_CFG_TX_DATA_MAX=3 -DMAC_CFG_TX_MAX=6         #
#                          -DMAC_CFG_RX_MAX=3) -f E:\´«¸ÐÆ÷ZStack-CC2530\´«¸Ð #
#                          Æ÷ZStack-CC2530-ÊµÑµ×îÖÕ°æ±¾\Projects\zstack\Sampl #
#                          es\dimmablelightApp\CC2530DB\..\..\..\Tools\CC2530 #
#                          DB\f8wConfig.cfg (-DZIGBEEPRO -DSECURE=0           #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST26=0x04000000                    #
#                          -DDEFAULT_CHANLIST25=0x02000000                    #
#                          -DDEFAULT_CHANLIST24=0x01000000                    #
#                          -DDEFAULT_CHANLIST23=0x00800000                    #
#                          -DDEFAULT_CHANLIST22=0x00400000                    #
#                          -DDEFAULT_CHANLIST21=0x00200000                    #
#                          -DDEFAULT_CHANLIST20=0x00100000                    #
#                          -DDEFAULT_CHANLIST19=0x00080000                    #
#                          -DDEFAULT_CHANLIST18=0x00040000                    #
#                          -DDEFAULT_CHANLIST17=0x00020000                    #
#                          -DDEFAULT_CHANLIST16=0x00010000                    #
#                          -DDEFAULT_CHANLIST15=0x00008000                    #
#                          -DDEFAULT_CHANLIST14=0x00004000                    #
#                          -DDEFAULT_CHANLIST13=0x00002000                    #
#                          -DDEFAULT_CHANLIST12=0x00001000                    #
#                          -DDEFAULT_CHANLIST11=0x00000800                    #
#                          -DDEFAULT_CHANLIST=DEFAULT_CHANLIST25              #
#                          -DZDAPP_CONFIG_PAN_ID=0x0006                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 E:\´«¸ÐÆ÷ZStack-CC2530\´«¸Ð #
#                          Æ÷ZStack-CC2530-ÊµÑµ×îÖÕ°æ±¾\Components\mt\MT_UTIL #
#                          .c -D NWK_AUTO_POLL -D ZTOOL_P1 -D MT_TASK -D      #
#                          MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED=DEBUG  #
#                          -D xPOWER_SAVING -lC E:\´«¸ÐÆ÷ZStack-CC2530\´«¸ÐÆ÷ #
#                          ZStack-CC2530-ÊµÑµ×îÖÕ°æ±¾\Projects\zstack\Samples #
#                          \dimmablelightApp\CC2530DB\EndDeviceEB\List\ -lA   #
#                          E:\´«¸ÐÆ÷ZStack-CC2530\´«¸ÐÆ÷ZStack-CC2530-ÊµÑµ×îÖ #
#                          Õ°æ±¾\Projects\zstack\Samples\dimmablelightApp\CC2 #
#                          530DB\EndDeviceEB\List\ --diag_suppress            #
#                          Pe001,Pa010 -o E:\´«¸ÐÆ÷ZStack-CC2530\´«¸ÐÆ÷ZStack #
#                          -CC2530-ÊµÑµ×îÖÕ°æ±¾\Projects\zstack\Samples\dimma #
#                          blelightApp\CC2530DB\EndDeviceEB\Obj\ -e           #
#                          --no_code_motion --debug --core=plain --dptr=16,1  #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I E:\´«¸ÐÆ÷ZStack-CC2530\´«¸ÐÆ÷ZStack-CC2530-ÊµÑµ #
#                          ×îÖÕ°æ±¾\Projects\zstack\Samples\dimmablelightApp\ #
#                          CC2530DB\ -I E:\´«¸ÐÆ÷ZStack-CC2530\´«¸ÐÆ÷ZStack-C #
#                          C2530-ÊµÑµ×îÖÕ°æ±¾\Projects\zstack\Samples\dimmabl #
#                          elightApp\CC2530DB\..\Source\ -I                   #
#                          E:\´«¸ÐÆ÷ZStack-CC2530\´«¸ÐÆ÷ZStack-CC2530-ÊµÑµ×îÖ #
#                          Õ°æ±¾\Projects\zstack\Samples\dimmablelightApp\CC2 #
#                          530DB\..\..\..\ZMain\TI2530DB\ -I                  #
#                          E:\´«¸ÐÆ÷ZStack-CC2530\´«¸ÐÆ÷ZStack-CC2530-ÊµÑµ×îÖ #
#                          Õ°æ±¾\Projects\zstack\Samples\dimmablelightApp\CC2 #
#                          530DB\..\..\..\..\..\Components\hal\include\ -I    #
#                          E:\´«¸ÐÆ÷ZStack-CC2530\´«¸ÐÆ÷ZStack-CC2530-ÊµÑµ×îÖ #
#                          Õ°æ±¾\Projects\zstack\Samples\dimmablelightApp\CC2 #
#                          530DB\..\..\..\..\..\Components\hal\target\CC2530E #
#                          B\ -I E:\´«¸ÐÆ÷ZStack-CC2530\´«¸ÐÆ÷ZStack-CC2530-Ê #
#                          µÑµ×îÖÕ°æ±¾\Projects\zstack\Samples\dimmablelightA #
#                          pp\CC2530DB\..\..\..\..\..\Components\mac\include\ #
#                           -I E:\´«¸ÐÆ÷ZStack-CC2530\´«¸ÐÆ÷ZStack-CC2530-ÊµÑ #
#                          µ×îÖÕ°æ±¾\Projects\zstack\Samples\dimmablelightApp #
#                          \CC2530DB\..\..\..\..\..\Components\mac\high_level #
#                          \ -I E:\´«¸ÐÆ÷ZStack-CC2530\´«¸ÐÆ÷ZStack-CC2530-Êµ #
#                          Ñµ×îÖÕ°æ±¾\Projects\zstack\Samples\dimmablelightAp #
#                          p\CC2530DB\..\..\..\..\..\Components\mac\low_level #
#                          \srf04\ -I E:\´«¸ÐÆ÷ZStack-CC2530\´«¸ÐÆ÷ZStack-CC2 #
#                          530-ÊµÑµ×îÖÕ°æ±¾\Projects\zstack\Samples\dimmablel #
#                          ightApp\CC2530DB\..\..\..\..\..\Components\mac\low #
#                          _level\srf04\single_chip\ -I                       #
#                          E:\´«¸ÐÆ÷ZStack-CC2530\´«¸ÐÆ÷ZStack-CC2530-ÊµÑµ×îÖ #
#                          Õ°æ±¾\Projects\zstack\Samples\dimmablelightApp\CC2 #
#                          530DB\..\..\..\..\..\Components\mt\ -I             #
#                          E:\´«¸ÐÆ÷ZStack-CC2530\´«¸ÐÆ÷ZStack-CC2530-ÊµÑµ×îÖ #
#                          Õ°æ±¾\Projects\zstack\Samples\dimmablelightApp\CC2 #
#                          530DB\..\..\..\..\..\Components\osal\include\ -I   #
#                          E:\´«¸ÐÆ÷ZStack-CC2530\´«¸ÐÆ÷ZStack-CC2530-ÊµÑµ×îÖ #
#                          Õ°æ±¾\Projects\zstack\Samples\dimmablelightApp\CC2 #
#                          530DB\..\..\..\..\..\Components\services\saddr\    #
#                          -I E:\´«¸ÐÆ÷ZStack-CC2530\´«¸ÐÆ÷ZStack-CC2530-ÊµÑµ #
#                          ×îÖÕ°æ±¾\Projects\zstack\Samples\dimmablelightApp\ #
#                          CC2530DB\..\..\..\..\..\Components\services\sdata\ #
#                           -I E:\´«¸ÐÆ÷ZStack-CC2530\´«¸ÐÆ÷ZStack-CC2530-ÊµÑ #
#                          µ×îÖÕ°æ±¾\Projects\zstack\Samples\dimmablelightApp #
#                          \CC2530DB\..\..\..\..\..\Components\stack\af\ -I   #
#                          E:\´«¸ÐÆ÷ZStack-CC2530\´«¸ÐÆ÷ZStack-CC2530-ÊµÑµ×îÖ #
#                          Õ°æ±¾\Projects\zstack\Samples\dimmablelightApp\CC2 #
#                          530DB\..\..\..\..\..\Components\stack\nwk\ -I      #
#                          E:\´«¸ÐÆ÷ZStack-CC2530\´«¸ÐÆ÷ZStack-CC2530-ÊµÑµ×îÖ #
#                          Õ°æ±¾\Projects\zstack\Samples\dimmablelightApp\CC2 #
#                          530DB\..\..\..\..\..\Components\stack\sapi\ -I     #
#                          E:\´«¸ÐÆ÷ZStack-CC2530\´«¸ÐÆ÷ZStack-CC2530-ÊµÑµ×îÖ #
#                          Õ°æ±¾\Projects\zstack\Samples\dimmablelightApp\CC2 #
#                          530DB\..\..\..\..\..\Components\stack\sec\ -I      #
#                          E:\´«¸ÐÆ÷ZStack-CC2530\´«¸ÐÆ÷ZStack-CC2530-ÊµÑµ×îÖ #
#                          Õ°æ±¾\Projects\zstack\Samples\dimmablelightApp\CC2 #
#                          530DB\..\..\..\..\..\Components\stack\sys\ -I      #
#                          E:\´«¸ÐÆ÷ZStack-CC2530\´«¸ÐÆ÷ZStack-CC2530-ÊµÑµ×îÖ #
#                          Õ°æ±¾\Projects\zstack\Samples\dimmablelightApp\CC2 #
#                          530DB\..\..\..\..\..\Components\stack\zdo\ -I      #
#                          E:\´«¸ÐÆ÷ZStack-CC2530\´«¸ÐÆ÷ZStack-CC2530-ÊµÑµ×îÖ #
#                          Õ°æ±¾\Projects\zstack\Samples\dimmablelightApp\CC2 #
#                          530DB\..\..\..\..\..\Components\zmac\ -I           #
#                          E:\´«¸ÐÆ÷ZStack-CC2530\´«¸ÐÆ÷ZStack-CC2530-ÊµÑµ×îÖ #
#                          Õ°æ±¾\Projects\zstack\Samples\dimmablelightApp\CC2 #
#                          530DB\..\..\..\..\..\Components\zmac\f8w\ -Ohz     #
#                          --require_prototypes                               #
#    List file          =  E:\´«¸ÐÆ÷ZStack-CC2530\´«¸ÐÆ÷ZStack-CC2530-ÊµÑµ×îÖ #
#                          Õ°æ±¾\Projects\zstack\Samples\dimmablelightApp\CC2 #
#                          530DB\EndDeviceEB\List\MT_UTIL.lst                 #
#    Object file        =  E:\´«¸ÐÆ÷ZStack-CC2530\´«¸ÐÆ÷ZStack-CC2530-ÊµÑµ×îÖ #
#                          Õ°æ±¾\Projects\zstack\Samples\dimmablelightApp\CC2 #
#                          530DB\EndDeviceEB\Obj\MT_UTIL.r51                  #
#                                                                             #
#                                                                             #
###############################################################################

E:\´«¸ÐÆ÷ZStack-CC2530\´«¸ÐÆ÷ZStack-CC2530-ÊµÑµ×îÖÕ°æ±¾\Components\mt\MT_UTIL.c
      1          /***************************************************************************************************
      2            Filename:       MT_UTIL.c
      3            Revised:        $Date: 2011-07-15 15:48:37 -0700 (Fri, 15 Jul 2011) $
      4            Revision:       $Revision: 26799 $
      5          
      6            Description:    MonitorTest Utility Functions
      7          
      8            Copyright 2007-2011 Texas Instruments Incorporated. All rights reserved.
      9          
     10            IMPORTANT: Your use of this Software is limited to those specific rights
     11            granted under the terms of a software license agreement between the user
     12            who downloaded the software, his/her employer (which must be your employer)
     13            and Texas Instruments Incorporated (the "License").  You may not use this
     14            Software unless you agree to abide by the terms of the License. The License
     15            limits your use, and you acknowledge, that the Software may not be modified,
     16            copied or distributed unless embedded on a Texas Instruments microcontroller
     17            or used solely and exclusively in conjunction with a Texas Instruments radio
     18            frequency transceiver, which is integrated into your product.  Other than for
     19            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     20            works of, modify, distribute, perform, display or sell this Software and/or
     21            its documentation for any purpose.
     22          
     23            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     24            PROVIDED “AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     25            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     26            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     27            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     28            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     29            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     30            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     31            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     32            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     33            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     34          
     35            Should you have any questions regarding your right to use this Software,
     36            contact Texas Instruments Incorporated at www.TI.com.
     37          
     38           ***************************************************************************************************/
     39          
     40          /***************************************************************************************************
     41           * INCLUDES
     42           ***************************************************************************************************/
     43          #include "ZComDef.h"
     44          
     45          #include "AddrMgr.h"
     46          
     47          #include "OnBoard.h"   /* This is here because of the key reading */
     48          #include "hal_key.h"
     49          #include "hal_led.h"
     50          #include "OSAL_Nv.h"
     51          #include "osal.h"
     52          #include "NLMEDE.h"
     53          #include "MT.h"
     54          #include "MT_UTIL.h"
     55          #include "MT_MAC.h"
     56          #include "ssp.h"
     57          #if defined ZCL_KEY_ESTABLISH
     58          #include "zcl_key_establish.h"
     59          #endif
     60          #if defined TC_LINKKEY_JOIN
     61          #include "zcl_se.h"
     62          #endif
     63          
     64          #if !defined NONWK
     65          #include "MT_ZDO.h"
     66          #include "MT_SAPI.h"
     67          #include "MT_NWK.h"
     68          #include "MT_AF.h"
     69          #include "AssocList.h"
     70          #include "ZDApp.h"
     71          #include "ZDSecMgr.h"
     72          #endif
     73          /***************************************************************************************************
     74           * CONSTANTS
     75           ***************************************************************************************************/
     76          #define MT_UTIL_DEVICE_INFO_RESPONSE_LEN 14
     77          #define MT_UTIL_STATUS_LEN    1
     78          #define MT_UTIL_FRM_CTR_LEN   4
     79          // Status + LinkKeyDataLen + Tx+Rx Frame counter.
     80          #define MT_APSME_LINKKEY_GET_RSP_LEN (MT_UTIL_STATUS_LEN + SEC_KEY_LEN + (MT_UTIL_FRM_CTR_LEN * 2))
     81          // Status + NV id
     82          #define MT_APSME_LINKKEY_NV_ID_GET_RSP_LEN (MT_UTIL_STATUS_LEN + 2)
     83          
     84          /***************************************************************************************************
     85           * LOCAL VARIABLES
     86           ***************************************************************************************************/
     87          #if defined ZCL_KEY_ESTABLISH
     88          uint8 zcl_key_establish_task_id;
     89          #endif
     90          
     91          /***************************************************************************************************
     92           * LOCAL FUNCTIONS
     93           ***************************************************************************************************/
     94          #ifdef AUTO_PEND
     95          static void MT_UtilRevExtCpy( uint8 *pDst, uint8 *pSrc );
     96          static void MT_UtilSpi2Addr( zAddrType_t *pDst, uint8 *pSrc );
     97          #endif
     98          
     99          #if defined (MT_UTIL_FUNC)
    100          void MT_UtilGetDeviceInfo(void);
    101          void MT_UtilGetNvInfo(void);
    102          void MT_UtilSetPanID(uint8 *pBuf);
    103          void MT_UtilSetChannels(uint8 *pBuf);
    104          void MT_UtilSetSecLevel(uint8 *pBuf);
    105          void MT_UtilSetPreCfgKey(uint8 *pBuf);
    106          void MT_UtilCallbackSub(uint8 *pData);
    107          void MT_UtilKeyEvent(uint8 *pBuf);
    108          void MT_UtilTimeAlive(void);
    109          void MT_UtilLedControl(uint8 *pBuf);
    110          void MT_UtilSrcMatchEnable (uint8 *pBuf);
    111          void MT_UtilSrcMatchAddEntry (uint8 *pBuf);
    112          void MT_UtilSrcMatchDeleteEntry (uint8 *pBuf);
    113          void MT_UtilSrcMatchCheckSrcAddr (uint8 *pBuf);
    114          void MT_UtilSrcMatchAckAllPending (uint8 *pBuf);
    115          void MT_UtilSrcMatchCheckAllPending (uint8 *pBuf);
    116          
    117          #if !defined NONWK
    118          void MT_UtilDataReq(uint8 *pBuf);
    119          static void MT_UtilAddrMgrExtAddrLookup(uint8 *pBuf);
    120          static void MT_UtilAddrMgrEntryLookupNwk(uint8 *pBuf);
    121          #if defined MT_SYS_KEY_MANAGEMENT
    122          static void MT_UtilAPSME_LinkKeyDataGet(uint8 *pBuf);
    123          static void MT_UtilAPSME_LinkKeyNvIdGet(uint8 *pBuf);
    124          #endif //MT_SYS_KEY_MANAGEMENT
    125          static void MT_UtilAPSME_RequestKeyCmd(uint8 *pBuf);
    126          static void MT_UtilAssocCount(uint8 *pBuf);
    127          static void MT_UtilAssocFindDevice(uint8 *pBuf);
    128          static void MT_UtilAssocGetWithAddress(uint8 *pBuf);
    129          static void packDev_t(uint8 *pBuf, associated_devices_t *pDev);
    130          #if defined ZCL_KEY_ESTABLISH
    131          static void MT_UtilzclGeneral_KeyEstablish_InitiateKeyEstablishment(uint8 *pBuf);
    132          static void MT_UtilzclGeneral_KeyEstablishment_ECDSASign(uint8 *pBuf);
    133          #endif // ZCL_KEY_ESTABLISH
    134          static void MT_UtilSync(void);
    135          #endif // !defined NONWK
    136          #endif // MT_UTIL_FUNC
    137          
    138          #if defined (MT_UTIL_FUNC)
    139          /***************************************************************************************************
    140           * @fn      MT_UtilProcessing
    141           *
    142           * @brief   Process all the DEBUG commands that are issued by test tool
    143           *
    144           * @param   pBuf  - pointer to received SPI data message
    145           *
    146           * @return  status
    147           ***************************************************************************************************/
    148          uint8 MT_UtilCommandProcessing(uint8 *pBuf)
    149          {
    150            uint8 status = MT_RPC_SUCCESS;
    151          
    152            switch (pBuf[MT_RPC_POS_CMD1])
    153            {
    154          // CC253X MAC Network Processor does not have NV support
    155          #if !defined(CC253X_MACNP)
    156              case MT_UTIL_GET_DEVICE_INFO:
    157                MT_UtilGetDeviceInfo();
    158                break;
    159          
    160              case MT_UTIL_GET_NV_INFO:
    161                MT_UtilGetNvInfo();
    162                break;
    163          
    164              case MT_UTIL_SET_PANID:
    165                MT_UtilSetPanID(pBuf);
    166                break;
    167          
    168              case MT_UTIL_SET_CHANNELS:
    169                MT_UtilSetChannels(pBuf);
    170                break;
    171          
    172              case MT_UTIL_SET_SECLEVEL:
    173                MT_UtilSetSecLevel(pBuf);
    174                break;
    175          
    176              case MT_UTIL_SET_PRECFGKEY:
    177                MT_UtilSetPreCfgKey(pBuf);
    178                break;
    179          #endif
    180              case MT_UTIL_CALLBACK_SUB_CMD:
    181                MT_UtilCallbackSub(pBuf);
    182                break;
    183          
    184              case MT_UTIL_KEY_EVENT:
    185          #if (defined HAL_KEY) && (HAL_KEY == TRUE)
    186                MT_UtilKeyEvent(pBuf);
    187          #endif
    188                break;
    189          
    190              case MT_UTIL_TIME_ALIVE:
    191                MT_UtilTimeAlive();
    192                break;
    193          
    194              case MT_UTIL_LED_CONTROL:
    195          #if (defined HAL_LED) && (HAL_LED == TRUE)
    196                MT_UtilLedControl(pBuf);
    197          #endif
    198                break;
    199          
    200              case MT_UTIL_SRC_MATCH_ENABLE:
    201                MT_UtilSrcMatchEnable(pBuf);
    202                break;
    203          
    204              case MT_UTIL_SRC_MATCH_ADD_ENTRY:
    205                MT_UtilSrcMatchAddEntry(pBuf);
    206                break;
    207          
    208              case MT_UTIL_SRC_MATCH_DEL_ENTRY:
    209                MT_UtilSrcMatchDeleteEntry(pBuf);
    210                break;
    211          
    212              case MT_UTIL_SRC_MATCH_CHECK_SRC_ADDR:
    213                MT_UtilSrcMatchCheckSrcAddr(pBuf);
    214                break;
    215          
    216              case MT_UTIL_SRC_MATCH_ACK_ALL_PENDING:
    217                MT_UtilSrcMatchAckAllPending(pBuf);
    218                break;
    219          
    220              case MT_UTIL_SRC_MATCH_CHECK_ALL_PENDING:
    221                MT_UtilSrcMatchCheckAllPending(pBuf);
    222                break;
    223          
    224              case MT_UTIL_TEST_LOOPBACK:
    225                MT_BuildAndSendZToolResponse((MT_RPC_CMD_SRSP|(uint8)MT_RPC_SYS_UTIL), MT_UTIL_TEST_LOOPBACK,
    226                                              pBuf[MT_RPC_POS_LEN], (pBuf+MT_RPC_FRAME_HDR_SZ));
    227                break;
    228          
    229          #if !defined NONWK
    230              case MT_UTIL_DATA_REQ:
    231                MT_UtilDataReq(pBuf);
    232                break;
    233          
    234              case MT_UTIL_ADDRMGR_EXT_ADDR_LOOKUP:
    235                MT_UtilAddrMgrExtAddrLookup(pBuf);
    236                break;
    237          
    238              case MT_UTIL_ADDRMGR_NWK_ADDR_LOOKUP:
    239                MT_UtilAddrMgrEntryLookupNwk(pBuf);
    240                break;
    241          
    242          #if defined MT_SYS_KEY_MANAGEMENT
    243              case MT_UTIL_APSME_LINK_KEY_DATA_GET:
    244                MT_UtilAPSME_LinkKeyDataGet(pBuf);
    245                break;
    246          
    247              case MT_UTIL_APSME_LINK_KEY_NV_ID_GET:
    248                MT_UtilAPSME_LinkKeyNvIdGet(pBuf);
    249                break;
    250          #endif // MT_SYS_KEY_MANAGEMENT
    251          
    252              case MT_UTIL_APSME_REQUEST_KEY_CMD:
    253                MT_UtilAPSME_RequestKeyCmd(pBuf);
    254                break;
    255          
    256              case MT_UTIL_ASSOC_COUNT:
    257                MT_UtilAssocCount(pBuf);
    258                break;
    259          
    260              case MT_UTIL_ASSOC_FIND_DEVICE:
    261                MT_UtilAssocFindDevice(pBuf);
    262                break;
    263          
    264              case MT_UTIL_ASSOC_GET_WITH_ADDRESS:
    265                MT_UtilAssocGetWithAddress(pBuf);
    266                break;
    267          
    268          #if defined ZCL_KEY_ESTABLISH
    269              case MT_UTIL_ZCL_KEY_EST_INIT_EST:
    270                MT_UtilzclGeneral_KeyEstablish_InitiateKeyEstablishment(pBuf);
    271                break;
    272          
    273              case MT_UTIL_ZCL_KEY_EST_SIGN:
    274                MT_UtilzclGeneral_KeyEstablishment_ECDSASign(pBuf);
    275                break;
    276          #endif
    277          
    278              case MT_UTIL_SYNC_REQ:
    279                MT_UtilSync();
    280                break;
    281          #endif /* !defined NONWK */
    282          
    283              default:
    284                status = MT_RPC_ERR_COMMAND_ID;
    285                break;
    286            }
    287          
    288            return status;
    289          }
    290          
    291          /***************************************************************************************************
    292           * @fn      MT_UtilGetDeviceInfo
    293           *
    294           * @brief   The Get Device Info serial message.
    295           *
    296           * @param   None.
    297           *
    298           * @return  void
    299           ***************************************************************************************************/
    300          void MT_UtilGetDeviceInfo(void)
    301          {
    302            uint8  *buf;
    303            uint8  *pBuf;
    304            uint8  bufLen = MT_UTIL_DEVICE_INFO_RESPONSE_LEN;
    305            uint16 *assocList = NULL;
    306          
    307          #if !defined NONWK
    308            uint8  assocCnt = 0;
    309          
    310            if (ZG_DEVICE_RTR_TYPE)
    311            {
    312              assocList = AssocMakeList( &assocCnt );
    313              bufLen += (assocCnt * sizeof(uint16));
    314            }
    315          #endif
    316          
    317            buf = osal_mem_alloc( bufLen );
    318            if ( buf )
    319            {
    320              pBuf = buf;
    321          
    322              *pBuf++ = ZSUCCESS; // Status
    323          
    324              osal_nv_read( ZCD_NV_EXTADDR, 0, Z_EXTADDR_LEN, pBuf );
    325              pBuf += Z_EXTADDR_LEN;
    326          
    327          #if defined NONWK
    328              // Skip past ZStack only parameters for NONWK
    329              *pBuf++ = 0;
    330              *pBuf++ = 0;
    331              *pBuf++ = 0;
    332              *pBuf++ = 0;
    333              *pBuf = 0;
    334          #else
    335              {
    336                uint16 shortAddr = NLME_GetShortAddr();
    337                *pBuf++ = LO_UINT16( shortAddr );
    338                *pBuf++ = HI_UINT16( shortAddr );
    339              }
    340          
    341              /* Return device type */
    342              *pBuf++ = ZSTACK_DEVICE_BUILD;
    343          
    344              /*Return device state */
    345              *pBuf++ = (uint8)devState;
    346          
    347              if (ZG_DEVICE_RTR_TYPE)
    348              {
    349                *pBuf++ = assocCnt;
    350          
    351                if ( assocCnt )
    352                {
    353                  uint8 x;
    354                  uint16 *puint16 = assocList;
    355          
    356                  for ( x = 0; x < assocCnt; x++, puint16++ )
    357                  {
    358                    *pBuf++ = LO_UINT16( *puint16 );
    359                    *pBuf++ = HI_UINT16( *puint16 );
    360                  }
    361                }
    362              }
    363              else
    364              {
    365                *pBuf++ = 0;
    366              }
    367          #endif
    368          
    369              MT_BuildAndSendZToolResponse( ((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL),
    370                                           MT_UTIL_GET_DEVICE_INFO,
    371                                           bufLen, buf );
    372          
    373              osal_mem_free( buf );
    374            }
    375          
    376            if ( assocList )
    377            {
    378              osal_mem_free( assocList );
    379            }
    380          }
    381          
    382          /***************************************************************************************************
    383           * @fn      MT_UtilGetNvInfo
    384           *
    385           * @brief   The Get NV Info serial message.
    386           *
    387           * @param   None.
    388           *
    389           * @return  void
    390           ***************************************************************************************************/
    391          void MT_UtilGetNvInfo(void)
    392          {
    393            uint8 len;
    394            uint8 stat;
    395            uint8 *buf;
    396            uint8 *pBuf;
    397            uint16 tmp16;
    398            uint32 tmp32;
    399          
    400            /*
    401              Get required length of buffer
    402              Status + ExtAddr + ChanList + PanID  + SecLevel + PreCfgKey
    403            */
    404            len = 1 + Z_EXTADDR_LEN + 4 + 2 + 1 + SEC_KEY_LEN;
    405          
    406            buf = osal_mem_alloc( len );
    407            if ( buf )
    408            {
    409              /* Assume NV not available */
    410              osal_memset( buf, 0xFF, len );
    411          
    412              /* Skip over status */
    413              pBuf = buf + 1;
    414          
    415              /* Start with 64-bit extended address */
    416              stat = osal_nv_read( ZCD_NV_EXTADDR, 0, Z_EXTADDR_LEN, pBuf );
    417              if ( stat ) stat = 0x01;
    418              pBuf += Z_EXTADDR_LEN;
    419          
    420              /* Scan channel list (bit mask) */
    421              if (  osal_nv_read( ZCD_NV_CHANLIST, 0, sizeof( tmp32 ), &tmp32 ) )
    422                stat |= 0x02;
    423              else
    424              {
    425                pBuf[0] = BREAK_UINT32( tmp32, 3 );
    426                pBuf[1] = BREAK_UINT32( tmp32, 2 );
    427                pBuf[2] = BREAK_UINT32( tmp32, 1 );
    428                pBuf[3] = BREAK_UINT32( tmp32, 0 );
    429              }
    430              pBuf += sizeof( tmp32 );
    431          
    432              /* ZigBee PanID */
    433              if ( osal_nv_read( ZCD_NV_PANID, 0, sizeof( tmp16 ), &tmp16 ) )
    434                stat |= 0x04;
    435              else
    436              {
    437                pBuf[0] = LO_UINT16( tmp16 );
    438                pBuf[1] = HI_UINT16( tmp16 );
    439              }
    440              pBuf += sizeof( tmp16 );
    441          
    442              /* Security level */
    443              if ( osal_nv_read( ZCD_NV_SECURITY_LEVEL, 0, sizeof( uint8 ), pBuf++ ) )
    444                stat |= 0x08;
    445          
    446              /* Pre-configured security key */
    447              if ( osal_nv_read( ZCD_NV_PRECFGKEY, 0, SEC_KEY_LEN, pBuf ) )
    448                stat |= 0x10;
    449          
    450              /* Status bit mask - bit=1 indicates failure */
    451              *buf = stat;
    452          
    453              MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), MT_UTIL_GET_NV_INFO,
    454                                            len, buf );
    455          
    456              osal_mem_free( buf );
    457            }
    458          }
    459          
    460          /***************************************************************************************************
    461           * @fn      MT_UtilSetPanID
    462           *
    463           * @brief   Set PanID message
    464           *
    465           * @param   pBuf - pointer to the data
    466           *
    467           * @return  void
    468           ***************************************************************************************************/
    469          void MT_UtilSetPanID(uint8 *pBuf)
    470          {
    471            uint16 temp16;
    472            uint8 retValue = ZFailure;
    473            uint8 cmdId;
    474          
    475            /* parse header */
    476            cmdId = pBuf[MT_RPC_POS_CMD1];
    477            pBuf += MT_RPC_FRAME_HDR_SZ;
    478          
    479            temp16 = BUILD_UINT16(pBuf[0], pBuf[1]);
    480            pBuf += sizeof(uint16);
    481          
    482            retValue = osal_nv_write(ZCD_NV_PANID, 0, osal_nv_item_len( ZCD_NV_PANID ), &temp16);
    483          
    484            /* Build and send back the response */
    485            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue);
    486          }
    487          
    488          /***************************************************************************************************
    489           * @fn      MT_UtilSetChannels
    490           *
    491           * @brief   Set Channels
    492           *
    493           * @param   pBuf - pointer to the data
    494           *
    495           * @return  void
    496           ***************************************************************************************************/
    497          void MT_UtilSetChannels(uint8 *pBuf)
    498          {
    499            uint32 tmp32;
    500            uint8 retValue = ZFailure;
    501            uint8 cmdId;
    502          
    503            /* parse header */
    504            cmdId = pBuf[MT_RPC_POS_CMD1];
    505            pBuf += MT_RPC_FRAME_HDR_SZ;
    506          
    507            tmp32 = BUILD_UINT32(pBuf[0], pBuf[1], pBuf[2], pBuf[3]);
    508          
    509            retValue = osal_nv_write(ZCD_NV_CHANLIST, 0, osal_nv_item_len( ZCD_NV_CHANLIST ), &tmp32);
    510          
    511            /* Build and send back the response */
    512            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue);
    513          }
    514          
    515          /***************************************************************************************************
    516           * @fn      MT_UtilSetSecLevel
    517           *
    518           * @brief   Set Sec Level
    519           *
    520           * @param   byte *msg - pointer to the data
    521           *
    522           * @return  void
    523           ***************************************************************************************************/
    524          void MT_UtilSetSecLevel(uint8 *pBuf)
    525          {
    526            uint8 retValue = ZFailure;
    527            uint8 cmdId;
    528          
    529            /* parse header */
    530            cmdId = pBuf[MT_RPC_POS_CMD1];
    531            pBuf += MT_RPC_FRAME_HDR_SZ;
    532          
    533            retValue = osal_nv_write( ZCD_NV_SECURITY_LEVEL, 0, osal_nv_item_len( ZCD_NV_SECURITY_LEVEL ), pBuf);
    534          
    535            /* Build and send back the response */
    536            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
    537          
    538          }
    539          
    540          /***************************************************************************************************
    541           * @fn      MT_UtilSetPreCfgKey
    542           *
    543           * @brief   Set Pre Cfg Key
    544           *
    545           * @param   pBuf - pointer to the data
    546           *
    547           * @return  void
    548           ***************************************************************************************************/
    549          void MT_UtilSetPreCfgKey(uint8 *pBuf)
    550          {
    551            uint8 retValue = ZFailure;
    552            uint8 cmdId;
    553          
    554            /* parse header */
    555            cmdId = pBuf[MT_RPC_POS_CMD1];
    556            pBuf += MT_RPC_FRAME_HDR_SZ;
    557          
    558            retValue = osal_nv_write( ZCD_NV_PRECFGKEY, 0, osal_nv_item_len( ZCD_NV_PRECFGKEY ), pBuf);
    559          
    560            /* Build and send back the response */
    561            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
    562          
    563          }
    564          
    565          /***************************************************************************************************
    566           * @fn      MT_UtilCallbackSub
    567           *
    568           * @brief   The Callback subscribe.
    569           *
    570           * @param   pBuf - pointer to the data
    571           *
    572           * @return  void
    573           ***************************************************************************************************/
    574          void MT_UtilCallbackSub(uint8 *pBuf)
    575          {
    576            uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
    577            uint8 retValue = ZFailure;
    578          
    579          #if defined(MT_MAC_CB_FUNC) || defined(MT_NWK_CB_FUNC) || defined(MT_ZDO_CB_FUNC) || defined(MT_AF_CB_FUNC) || defined(MT_SAPI_CB_FUNC)
    580            uint8 subSystem;
    581            uint16 subscribed_command;
    582          
    583            // Move past header
    584            retValue = ZSuccess;
    585            pBuf += MT_RPC_FRAME_HDR_SZ;
    586          
    587            /* Command */
    588            subscribed_command = BUILD_UINT16(pBuf[0], pBuf[1]);
    589            pBuf += 2;
    590          
    591            /* Subsystem - 5 bits on the MSB of the command */
    592            subSystem = HI_UINT16(subscribed_command) & 0x1F ;
    593          
    594            /* What is the action - SUBSCRIBE or !SUBSCRIBE */
    595            if (*pBuf)
    596            {
    597              /* Turn ON */
    598            #if defined( MT_MAC_CB_FUNC )
    599              if ((subSystem == MT_RPC_SYS_MAC) || (subscribed_command == 0xFFFF))
    600                _macCallbackSub = 0xFFFF;
    601            #endif
    602          
    603            #if defined( MT_NWK_CB_FUNC )
    604              if ((subSystem == MT_RPC_SYS_NWK) || (subscribed_command == 0xFFFF))
    605                _nwkCallbackSub = 0xFFFF;
    606            #endif
    607          
    608            #if defined( MT_ZDO_CB_FUNC )
    609              if ((subSystem == MT_RPC_SYS_ZDO) || (subscribed_command == 0xFFFF))
    610                _zdoCallbackSub = 0xFFFFFFFF;
    611            #endif
    612          
    613            #if defined( MT_AF_CB_FUNC )
    614              if ((subSystem == MT_RPC_SYS_AF) || (subscribed_command == 0xFFFF))
    615                _afCallbackSub = 0xFFFF;
    616            #endif
    617          
    618            #if defined( MT_SAPI_CB_FUNC )
    619              if ((subSystem == MT_RPC_SYS_SAPI) || (subscribed_command == 0xFFFF))
    620                _sapiCallbackSub = 0xFFFF;
    621            #endif
    622            }
    623            else
    624            {
    625              /* Turn OFF */
    626            #if defined( MT_MAC_CB_FUNC )
    627              if ((subSystem == MT_RPC_SYS_MAC) || (subscribed_command == 0xFFFF))
    628                _macCallbackSub = 0x0000;
    629            #endif
    630          
    631            #if defined( MT_NWK_CB_FUNC )
    632              if ((subSystem == MT_RPC_SYS_NWK) || (subscribed_command == 0xFFFF))
    633                _nwkCallbackSub = 0x0000;
    634            #endif
    635          
    636            #if defined( MT_ZDO_CB_FUNC )
    637              if ((subSystem == MT_RPC_SYS_ZDO) || (subscribed_command == 0xFFFF))
    638                _zdoCallbackSub = 0x00000000;
    639            #endif
    640          
    641            #if defined( MT_AF_CB_FUNC )
    642              if ((subSystem == MT_RPC_SYS_AF) || (subscribed_command == 0xFFFF))
    643                _afCallbackSub = 0x0000;
    644            #endif
    645          
    646            #if defined( MT_SAPI_CB_FUNC )
    647              if ((subSystem == MT_RPC_SYS_SAPI) || (subscribed_command == 0xFFFF))
    648                  _sapiCallbackSub = 0x0000;
    649            #endif
    650            }
    651          #endif  // MT_MAC_CB_FUNC || MT_NWK_CB_FUNC || MT_ZDO_CB_FUNC || MT_AF_CB_FUNC || MT_SAPI_CB_FUNC || MT_SAPI_CB_FUNC
    652          
    653            /* Build and send back the response */
    654            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
    655          }
    656          
    657          #if (defined HAL_KEY) && (HAL_KEY == TRUE)
    658          /***************************************************************************************************
    659           * @fn      MT_UtilKeyEvent
    660           *
    661           * @brief   Process Key Event
    662           *
    663           * @param   pBuf - pointer to the data
    664           *
    665           * @return  void
    666           ***************************************************************************************************/
    667          void MT_UtilKeyEvent(uint8 *pBuf)
    668          {
    669            uint8 x = 0;
    670            uint8 retValue = ZFailure;
    671            uint8 cmdId;
    672          
    673            /* parse header */
    674            cmdId = pBuf[MT_RPC_POS_CMD1];
    675            pBuf += MT_RPC_FRAME_HDR_SZ;
    676          
    677            /* Translate between SPI values to device values */
    678            if ( *pBuf & 0x01 )
    679              x |= HAL_KEY_SW_1;
    680            if ( *pBuf & 0x02 )
    681              x |= HAL_KEY_SW_2;
    682            if ( *pBuf & 0x04 )
    683              x |= HAL_KEY_SW_3;
    684            if ( *pBuf & 0x08 )
    685            x |= HAL_KEY_SW_4;
    686          #if defined ( HAL_KEY_SW_5 )
    687            if ( *pBuf & 0x10 )
    688              x |= HAL_KEY_SW_5;
    689          #endif
    690          #if defined ( HAL_KEY_SW_6 )
    691            if ( *pBuf & 0x20 )
    692              x |= HAL_KEY_SW_6;
    693          #endif
    694          #if defined ( HAL_KEY_SW_7 )
    695            if ( *pBuf & 0x40 )
    696              x |= HAL_KEY_SW_7;
    697          #endif
    698          #if defined ( HAL_KEY_SW_8 )
    699            if ( *pBuf & 0x80 )
    700              x |= HAL_KEY_SW_8;
    701          #endif
    702            pBuf++;
    703          
    704            retValue = OnBoard_SendKeys(x, *pBuf);
    705          
    706            /* Build and send back the response */
    707            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
    708          }
    709          #endif
    710          
    711          /***************************************************************************************************
    712           * @fn      MT_UtilTimeAlive
    713           *
    714           * @brief   Process Time Alive
    715           *
    716           * @param   None.
    717           *
    718           * @return  None
    719           ***************************************************************************************************/
    720          void MT_UtilTimeAlive(void)
    721          {
    722            uint8 timeAlive[4];
    723            uint32 tmp32;
    724          
    725            /* Time since last reset (seconds) */
    726            tmp32 = osal_GetSystemClock() / 1000;
    727          
    728            /* Convert to high byte first into temp buffer */
    729            timeAlive[0] = BREAK_UINT32(tmp32, 0);
    730            timeAlive[1] = BREAK_UINT32(tmp32, 1);
    731            timeAlive[2] = BREAK_UINT32(tmp32, 2);
    732            timeAlive[3] = BREAK_UINT32(tmp32, 3);
    733          
    734            /* Build and send back the response */
    735            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL),
    736                                                 MT_UTIL_TIME_ALIVE, sizeof(timeAlive), timeAlive);
    737          }
    738          
    739          #if (defined HAL_LED) && (HAL_LED == TRUE)
    740          /***************************************************************************************************
    741           * @fn      MT_UtilLedControl
    742           *
    743           * @brief   Process the LED Control Message
    744           *
    745           * @param   pBuf - pointer to the received data
    746           *
    747           * @return  None
    748           ***************************************************************************************************/
    749          void MT_UtilLedControl(uint8 *pBuf)
    750          {
    751            uint8 iLed, Led, iMode, Mode, cmdId;
    752            uint8 retValue = ZFailure;
    753          
    754            /* parse header */
    755            cmdId = pBuf[MT_RPC_POS_CMD1];
    756            pBuf += MT_RPC_FRAME_HDR_SZ;
    757          
    758            /* LED and Mode */
    759            iLed = *pBuf++;
    760            iMode = *pBuf;
    761          
    762            if ( iLed == 1 )
    763              Led = HAL_LED_1;
    764            else if ( iLed == 2 )
    765              Led = HAL_LED_2;
    766            else if ( iLed == 3 )
    767              Led = HAL_LED_3;
    768            else if ( iLed == 4 )
    769              Led = HAL_LED_4;
    770            else if ( iLed == 0xFF )
    771              Led = HAL_LED_ALL;
    772            else
    773              Led = 0;
    774          
    775            if ( iMode == 0 )
    776              Mode = HAL_LED_MODE_OFF;
    777            else if ( iMode == 1 )
    778              Mode = HAL_LED_MODE_ON;
    779            else if ( iMode == 2 )
    780              Mode = HAL_LED_MODE_BLINK;
    781            else if ( iMode == 3 )
    782              Mode = HAL_LED_MODE_FLASH;
    783            else if ( iMode == 4 )
    784              Mode = HAL_LED_MODE_TOGGLE;
    785            else
    786              Led = 0;
    787          
    788            if ( Led != 0 )
    789            {
    790              HalLedSet (Led, Mode);
    791              retValue = ZSuccess;
    792            }
    793          
    794            /* Build and send back the response */
    795            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
    796          }
    797          #endif /* HAL_LED */
    798          
    799          
    800          /***************************************************************************************************
    801           * @fn          MT_UtilSrcMatchEnable
    802           *
    803           * @brief      Enabled AUTOPEND and source address matching.
    804           *
    805           * @param      pBuf - Buffer contains the data
    806           *
    807           * @return     void
    808           ***************************************************************************************************/
    809          void MT_UtilSrcMatchEnable (uint8 *pBuf)
    810          {
    811            uint8 retValue, cmdId;
    812          
    813            /* Parse header */
    814            cmdId = pBuf[MT_RPC_POS_CMD1];
    815            pBuf += MT_RPC_FRAME_HDR_SZ;
    816          
    817          #ifdef AUTO_PEND
    818            /* Call the routine */
    819            retValue = ZMacSrcMatchEnable (pBuf[0], pBuf[1]);
    820          #else
    821            retValue = ZMacUnsupported;
    822          #endif
    823          
    824            /* Build and send back the response */
    825            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
    826          
    827          }
    828          
    829          /***************************************************************************************************
    830           * @fn          MT_UtilSrcMatchAddEntry
    831           *
    832           * @brief       Add a short or extended address to source address table.
    833           *
    834           * @param       pBuf - Buffer contains the data
    835           *
    836           * @return      void
    837           ***************************************************************************************************/
    838          void MT_UtilSrcMatchAddEntry (uint8 *pBuf)
    839          {
    840            uint8 retValue, cmdId;
    841          
    842            /* Parse header */
    843            cmdId = pBuf[MT_RPC_POS_CMD1];
    844            pBuf += MT_RPC_FRAME_HDR_SZ;
    845          
    846          #ifdef AUTO_PEND
    847            uint16 panID;
    848            zAddrType_t devAddr;
    849          
    850            /* Address mode */
    851            devAddr.addrMode = *pBuf++;
    852          
    853            /* Address based on the address mode */
    854            MT_UtilSpi2Addr( &devAddr, pBuf);
    855            pBuf += Z_EXTADDR_LEN;
    856          
    857            /* PanID */
    858            panID = BUILD_UINT16( pBuf[0] , pBuf[1] );
    859          
    860            /* Call the routine */
    861            retValue =  ZMacSrcMatchAddEntry (&devAddr, panID);
    862          #else
    863            retValue = ZMacUnsupported;
    864          #endif
    865          
    866            /* Build and send back the response */
    867            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
    868          }
    869          
    870          /***************************************************************************************************
    871           * @fn          MT_UtilSrcMatchDeleteEntry
    872           *
    873           * @brief      Delete a short or extended address from source address table.
    874           *
    875           * @param      pBuf - Buffer contains the data
    876           *
    877           * @return     void
    878           ***************************************************************************************************/
    879          void MT_UtilSrcMatchDeleteEntry (uint8 *pBuf)
    880          {
    881            uint8 retValue, cmdId;
    882          
    883            /* Parse header */
    884            cmdId = pBuf[MT_RPC_POS_CMD1];
    885            pBuf += MT_RPC_FRAME_HDR_SZ;
    886          
    887          #ifdef AUTO_PEND
    888            uint16 panID;
    889            zAddrType_t devAddr;
    890          
    891            /* Address mode */
    892            devAddr.addrMode = *pBuf++;
    893          
    894            /* Address based on the address mode */
    895            MT_UtilSpi2Addr( &devAddr, pBuf);
    896            pBuf += Z_EXTADDR_LEN;
    897          
    898            /* PanID */
    899            panID = BUILD_UINT16( pBuf[0] , pBuf[1] );
    900          
    901            /* Call the routine */
    902            retValue =  ZMacSrcMatchDeleteEntry (&devAddr, panID);
    903          #else
    904            retValue = ZMacUnsupported;
    905          #endif
    906          
    907            /* Build and send back the response */
    908            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
    909          }
    910          
    911          /***************************************************************************************************
    912           * @fn          MT_UtilSrcMatchCheckSrcAddr
    913           *
    914           * @brief      Check if a short or extended address is in the source address table.
    915           *
    916           * @param      pBuf - Buffer contains the data
    917           *
    918           * @return     void
    919           ***************************************************************************************************/
    920          void MT_UtilSrcMatchCheckSrcAddr (uint8 *pBuf)
    921          {
    922            uint8 cmdId;
    923            uint8 retArray[2];
    924          
    925            /* Parse header */
    926            cmdId = pBuf[MT_RPC_POS_CMD1];
    927            pBuf += MT_RPC_FRAME_HDR_SZ;
    928          
    929          #if 0  /* Unsupported  */
    930            uint16 panID;
    931            zAddrType_t devAddr;
    932          
    933            /* Address mode */
    934            devAddr.addrMode = *pBuf++;
    935          
    936            /* Address based on the address mode */
    937            MT_UtilSpi2Addr( &devAddr, pBuf);
    938            pBuf += Z_EXTADDR_LEN;
    939          
    940            /* PanID */
    941            panID = BUILD_UINT16( pBuf[0] , pBuf[1] );
    942          
    943            /* Call the routine */
    944            retArray[1] =  ZMacSrcMatchCheckSrcAddr (&devAddr, panID);
    945          
    946              /* Return failure if the index is invalid */
    947            if (retArray[1] == ZMacSrcMatchInvalidIndex )
    948            {
    949              retArray[0] = ZFailure;
    950            }
    951            else
    952            {
    953              retArray[0] = ZSuccess;
    954            }
    955          #else
    956            retArray[0] = ZMacUnsupported;
    957            retArray[1] = ZMacSrcMatchInvalidIndex;
    958          #endif
    959          
    960            /* Build and send back the response */
    961            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 2, retArray );
    962          }
    963          
    964          /***************************************************************************************************
    965           * @fn          MT_UtilSrcMatchAckAllPending
    966           *
    967           * @brief       Enabled/disable acknowledging all packets with pending bit set
    968           *              It is normally enabled when adding new entries to
    969           *              the source address table fails due to the table is full, or
    970           *              disabled when more entries are deleted and the table has
    971           *              empty slots.
    972           *
    973           * @param       pBuf - Buffer contains the data
    974           *
    975           * @return      void
    976           ***************************************************************************************************/
    977          void MT_UtilSrcMatchAckAllPending (uint8 *pBuf)
    978          {
    979            uint8 retValue, cmdId;
    980          
    981            /* Parse header */
    982            cmdId = pBuf[MT_RPC_POS_CMD1];
    983            pBuf += MT_RPC_FRAME_HDR_SZ;
    984          
    985          #ifdef AUTO_PEND
    986            /* Call the routine */
    987            retValue = ZMacSrcMatchAckAllPending(*pBuf);
    988          #else
    989            retValue = ZMacUnsupported;
    990          #endif
    991          
    992            /* Build and send back the response */
    993            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
    994          }
    995          
    996          /***************************************************************************************************
    997           * @fn          MT_UtilSrcMatchCheckAllPending
    998           *
    999           * @brief       Check if acknowledging all packets with pending bit set
   1000           *              is enabled.
   1001           *
   1002           * @param       pBuf - Buffer contains the data
   1003           *
   1004           * @return      void
   1005           ***************************************************************************************************/
   1006          void MT_UtilSrcMatchCheckAllPending (uint8 *pBuf)
   1007          {
   1008            uint8 retArray[2], cmdId;
   1009          
   1010            /* Parse header */
   1011            cmdId = pBuf[MT_RPC_POS_CMD1];
   1012            pBuf += MT_RPC_FRAME_HDR_SZ;
   1013          
   1014          #ifdef AUTO_PEND
   1015            /* Call the routine */
   1016            retArray[0] = ZMacSuccess;
   1017            retArray[1] = ZMacSrcMatchCheckAllPending();
   1018          #else
   1019            retArray[0] = ZMacUnsupported;
   1020            retArray[1] = FALSE;
   1021          #endif
   1022          
   1023            /* Build and send back the response */
   1024            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 2, retArray );
   1025          }
   1026          
   1027          /***************************************************************************************************
   1028           * SUPPORT
   1029           ***************************************************************************************************/
   1030          
   1031          #ifdef AUTO_PEND
   1032          /***************************************************************************************************
   1033           * @fn      MT_UtilRevExtCpy
   1034           *
   1035           * @brief
   1036           *
   1037           *   Reverse-copy an extended address.
   1038           *
   1039           * @param   pDst - Pointer to data destination
   1040           * @param   pSrc - Pointer to data source
   1041           *
   1042           * @return  void
   1043           ***************************************************************************************************/
   1044          static void MT_UtilRevExtCpy( uint8 *pDst, uint8 *pSrc )
   1045          {
   1046            int8 i;
   1047          
   1048            for ( i = Z_EXTADDR_LEN - 1; i >= 0; i-- )
   1049            {
   1050              *pDst++ = pSrc[i];
   1051            }
   1052          }
   1053          
   1054          /***************************************************************************************************
   1055           * @fn      MT_UtilSpi2Addr
   1056           *
   1057           * @brief   Copy an address from an SPI message to an address struct.  The
   1058           *          addrMode in pAddr must already be set.
   1059           *
   1060           * @param   pDst - Pointer to address struct
   1061           * @param   pSrc - Pointer SPI message byte array
   1062           *
   1063           * @return  void
   1064           ***************************************************************************************************/
   1065          static void MT_UtilSpi2Addr( zAddrType_t *pDst, uint8 *pSrc )
   1066          {
   1067            if ( pDst->addrMode == Addr16Bit )
   1068            {
   1069              pDst->addr.shortAddr = BUILD_UINT16( pSrc[0] , pSrc[1] );
   1070            }
   1071            else if ( pDst->addrMode == Addr64Bit )
   1072            {
   1073              MT_UtilRevExtCpy( pDst->addr.extAddr, pSrc );
   1074            }
   1075          }
   1076          #endif // AUTO_PEND
   1077          
   1078          #if !defined NONWK
   1079          /**************************************************************************************************
   1080           * @fn      MT_UtilDataReq
   1081           *
   1082           * @brief   Process the MAC Data Request command.
   1083           *
   1084           * @param   pBuf - pointer to the received data
   1085           *
   1086           * @return  None
   1087          **************************************************************************************************/
   1088          void MT_UtilDataReq(uint8 *pBuf)
   1089          {
   1090            uint8 rtrn = NwkPollReq(pBuf[MT_RPC_POS_DAT0]);
   1091            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), MT_UTIL_DATA_REQ,
   1092                                                                                         1, &rtrn);
   1093          }
   1094          
   1095          /***************************************************************************************************
   1096           * @fn      MT_UtilAddrMgrExtAddrLookup
   1097           *
   1098           * @brief   Proxy the AddrMgrExtAddrLookup() function.
   1099           *
   1100           * @param   pBuf - pointer to the received buffer
   1101           *
   1102           * @return  void
   1103           ***************************************************************************************************/
   1104          static void MT_UtilAddrMgrExtAddrLookup(uint8 *pBuf)
   1105          {
   1106            uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
   1107            pBuf += MT_RPC_FRAME_HDR_SZ;
   1108          
   1109            (void)AddrMgrExtAddrLookup(BUILD_UINT16(pBuf[Z_EXTADDR_LEN], pBuf[Z_EXTADDR_LEN+1]), pBuf);
   1110            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
   1111                                                                         Z_EXTADDR_LEN, (uint8 *)pBuf);
   1112          }
   1113          
   1114          /***************************************************************************************************
   1115           * @fn      MT_UtilAddrMgrEntryLookupNwk
   1116           *
   1117           * @brief   Proxy the AddrMgrEntryLookupNwk() function.
   1118           *
   1119           * @param   pBuf - pointer to the received buffer
   1120           *
   1121           * @return  void
   1122           ***************************************************************************************************/
   1123          static void MT_UtilAddrMgrEntryLookupNwk(uint8 *pBuf)
   1124          {
   1125            AddrMgrEntry_t entry;
   1126            uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
   1127            pBuf += MT_RPC_FRAME_HDR_SZ;
   1128          
   1129            entry.nwkAddr = BUILD_UINT16(pBuf[0], pBuf[1]);
   1130            (void)AddrMgrEntryLookupNwk(&entry);
   1131            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
   1132                                                                            Z_EXTADDR_LEN, entry.extAddr);
   1133          }
   1134          
   1135          #if defined MT_SYS_KEY_MANAGEMENT
   1136          /***************************************************************************************************
   1137           * @fn      MT_UtilAPSME_LinkKeyDataGet
   1138           *
   1139           * @brief   Retrieves APS Link Key data from NV.
   1140           *
   1141           * @param   pBuf - pointer to the received buffer
   1142           *
   1143           * @return  void
   1144           ***************************************************************************************************/
   1145          static void MT_UtilAPSME_LinkKeyDataGet(uint8 *pBuf)
   1146          {
   1147            uint8 rsp[MT_APSME_LINKKEY_GET_RSP_LEN];
   1148            APSME_LinkKeyData_t *pData = NULL;
   1149            uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
   1150            uint16 apsLinkKeyNvId;
   1151            uint32 *apsRxFrmCntr;
   1152            uint32 *apsTxFrmCntr;
   1153          
   1154            pBuf += MT_RPC_FRAME_HDR_SZ;
   1155          
   1156            *rsp = APSME_LinkKeyNVIdGet(pBuf, &apsLinkKeyNvId);
   1157          
   1158            if (SUCCESS == *rsp)
   1159            {
   1160              pData = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   1161          
   1162              if (pData != NULL)
   1163              {
   1164                // retrieve key from NV
   1165                if ( osal_nv_read( apsLinkKeyNvId, 0,
   1166                                  sizeof(APSME_LinkKeyData_t), pData) == SUCCESS)
   1167          
   1168                {
   1169                  apsRxFrmCntr = &ApsLinkKeyFrmCntr[apsLinkKeyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].rxFrmCntr;
   1170                  apsTxFrmCntr = &ApsLinkKeyFrmCntr[apsLinkKeyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].txFrmCntr;
   1171          
   1172                  uint8 *ptr = rsp+1;
   1173                  (void)osal_memcpy(ptr, pData->key, SEC_KEY_LEN);
   1174                  ptr += SEC_KEY_LEN;
   1175                  *ptr++ = BREAK_UINT32(*apsTxFrmCntr, 0);
   1176                  *ptr++ = BREAK_UINT32(*apsTxFrmCntr, 1);
   1177                  *ptr++ = BREAK_UINT32(*apsTxFrmCntr, 2);
   1178                  *ptr++ = BREAK_UINT32(*apsTxFrmCntr, 3);
   1179                  *ptr++ = BREAK_UINT32(*apsRxFrmCntr, 0);
   1180                  *ptr++ = BREAK_UINT32(*apsRxFrmCntr, 1);
   1181                  *ptr++ = BREAK_UINT32(*apsRxFrmCntr, 2);
   1182                  *ptr++ = BREAK_UINT32(*apsRxFrmCntr, 3);
   1183                }
   1184          
   1185                // clear copy of key in RAM
   1186                osal_memset( pData, 0x00, sizeof(APSME_LinkKeyData_t) );
   1187          
   1188                osal_mem_free(pData);
   1189              }
   1190            }
   1191            else
   1192            {
   1193              // set data key and counters 0xFF
   1194              osal_memset(&rsp[1], 0xFF, SEC_KEY_LEN + (MT_UTIL_FRM_CTR_LEN * 2));
   1195            }
   1196          
   1197            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
   1198                                                 MT_APSME_LINKKEY_GET_RSP_LEN, rsp);
   1199          
   1200            // clear key data
   1201            osal_memset(rsp, 0x00, MT_APSME_LINKKEY_GET_RSP_LEN);
   1202          
   1203          }
   1204          
   1205          /***************************************************************************************************
   1206           * @fn      MT_UtilAPSME_LinkKeyNvIdGet
   1207           *
   1208           * @brief   Retrieves APS Link Key NV ID from the entry table.
   1209           *
   1210           * @param   pBuf - pointer to the received buffer
   1211           *
   1212           * @return  void
   1213           ***************************************************************************************************/
   1214          static void MT_UtilAPSME_LinkKeyNvIdGet(uint8 *pBuf)
   1215          {
   1216            uint8 rsp[MT_APSME_LINKKEY_NV_ID_GET_RSP_LEN];
   1217            uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
   1218            uint16 apsLinkKeyNvId;
   1219          
   1220            pBuf += MT_RPC_FRAME_HDR_SZ;
   1221          
   1222            *rsp = APSME_LinkKeyNVIdGet(pBuf, &apsLinkKeyNvId);
   1223          
   1224            if (SUCCESS == *rsp)
   1225            {
   1226              rsp[1] = LO_UINT16(apsLinkKeyNvId);
   1227              rsp[2] = HI_UINT16(apsLinkKeyNvId);
   1228            }
   1229            else
   1230            {
   1231              // send failure response with invalid NV ID
   1232              osal_memset(&rsp[1], 0xFF, 2);
   1233            }
   1234          
   1235            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
   1236                                                 MT_APSME_LINKKEY_NV_ID_GET_RSP_LEN, rsp);
   1237          }
   1238          #endif // MT_SYS_KEY_MANAGEMENT
   1239          
   1240          /***************************************************************************************************
   1241           * @fn      MT_UtilAPSME_RequestKeyCmd
   1242           *
   1243           * @brief   Send RequestKey command message to TC for a specific partner Address.
   1244           *
   1245           * @param   pBuf  - pointer to the received buffer
   1246           *
   1247           * @return  void
   1248           ***************************************************************************************************/
   1249          void MT_UtilAPSME_RequestKeyCmd(uint8 *pBuf)
   1250          {
   1251            uint8 cmdId;
   1252            uint8 partnerAddr[Z_EXTADDR_LEN];
   1253            uint8 retValue;
   1254          
   1255            // parse header
   1256            cmdId = pBuf[MT_RPC_POS_CMD1];
   1257            pBuf += MT_RPC_FRAME_HDR_SZ;
   1258          
   1259            /* PartnerAddress */
   1260            osal_memcpy(partnerAddr, pBuf, Z_EXTADDR_LEN);
   1261          
   1262            retValue = (uint8)ZDSecMgrRequestAppKey(partnerAddr);
   1263          
   1264            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue);
   1265          }
   1266          
   1267          /***************************************************************************************************
   1268           * @fn      MT_UtilAssocCount
   1269           *
   1270           * @brief   Proxy the AssocCount() function.
   1271           *
   1272           * @param   pBuf - pointer to the received buffer
   1273           *
   1274           * @return  void
   1275           ***************************************************************************************************/
   1276          static void MT_UtilAssocCount(uint8 *pBuf)
   1277          {
   1278            uint16 cnt;
   1279            uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
   1280            pBuf += MT_RPC_FRAME_HDR_SZ;
   1281          
   1282            cnt = AssocCount(pBuf[0], pBuf[1]);
   1283            pBuf[0] = LO_UINT16(cnt);
   1284            pBuf[1] = HI_UINT16(cnt);
   1285          
   1286            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 2, pBuf);
   1287          }
   1288          
   1289          /***************************************************************************************************
   1290           * @fn      MT_UtilAssocFindDevice
   1291           *
   1292           * @brief   Get an associated device by index.
   1293           *
   1294           * @param   pBuf - pointer to the received buffer
   1295           *
   1296           * @return  void
   1297           ***************************************************************************************************/
   1298          static void MT_UtilAssocFindDevice(uint8 *pBuf)
   1299          {
   1300            uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
   1301            uint8 buf[sizeof(associated_devices_t)];
   1302          
   1303            packDev_t(buf, AssocFindDevice(pBuf[MT_RPC_FRAME_HDR_SZ]));
   1304            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
   1305                                                 sizeof(associated_devices_t), buf);
   1306          }
   1307          
   1308          /***************************************************************************************************
   1309           * @fn      MT_UtilAssocGetWithAddress
   1310           *
   1311           * @brief   Get an associated device by address.
   1312           *
   1313           * @param   pBuf - pointer to the received buffer
   1314           *
   1315           * @return  void
   1316           ***************************************************************************************************/
   1317          static void MT_UtilAssocGetWithAddress(uint8 *pBuf)
   1318          {
   1319            extern associated_devices_t *AssocGetWithAddress(uint8 *extAddr, uint16 shortAddr);
   1320            uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
   1321            uint8 buf[sizeof(associated_devices_t)];
   1322          
   1323            pBuf += MT_RPC_FRAME_HDR_SZ;
   1324            packDev_t(buf, AssocGetWithAddress(((AddrMgrExtAddrValid(pBuf)) ? pBuf : NULL),
   1325                                            BUILD_UINT16(pBuf[Z_EXTADDR_LEN], pBuf[Z_EXTADDR_LEN+1])));
   1326          
   1327            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
   1328                                                 sizeof(associated_devices_t), buf);
   1329          }
   1330          
   1331          /***************************************************************************************************
   1332           * @fn      packDev_t
   1333           *
   1334           * @brief   Pack an associated_devices_t structure into a byte buffer (pack INVALID_NODE_ADDR if
   1335           *          the pDev parameter is NULL).
   1336           *
   1337           * @param   pBuf - pointer to the buffer into which to pack the structure.
   1338           * @param   pDev - pointer to the structure.
   1339           *
   1340           * @return  void
   1341           ***************************************************************************************************/
   1342          static void packDev_t(uint8 *pBuf, associated_devices_t *pDev)
   1343          {
   1344            if (NULL == pDev)
   1345            {
   1346              uint16 rtrn = INVALID_NODE_ADDR;
   1347              *pBuf++ = LO_UINT16(rtrn);
   1348              *pBuf++ = HI_UINT16(rtrn);
   1349            }
   1350            else
   1351            {
   1352              *pBuf++ = LO_UINT16(pDev->shortAddr);
   1353              *pBuf++ = HI_UINT16(pDev->shortAddr);
   1354              *pBuf++ = LO_UINT16(pDev->addrIdx);
   1355              *pBuf++ = HI_UINT16(pDev->addrIdx);
   1356              *pBuf++ = pDev->nodeRelation;
   1357              *pBuf++ = pDev->devStatus;
   1358              *pBuf++ = pDev->assocCnt;
   1359              *pBuf++ = pDev->age;
   1360              *pBuf++ = pDev->linkInfo.txCounter;
   1361              *pBuf++ = pDev->linkInfo.txCost;
   1362              *pBuf++ = pDev->linkInfo.rxLqi;
   1363              *pBuf++ = pDev->linkInfo.inKeySeqNum;
   1364              *pBuf++ = BREAK_UINT32(pDev->linkInfo.inFrmCntr, 0);
   1365              *pBuf++ = BREAK_UINT32(pDev->linkInfo.inFrmCntr, 1);
   1366              *pBuf++ = BREAK_UINT32(pDev->linkInfo.inFrmCntr, 2);
   1367              *pBuf++ = BREAK_UINT32(pDev->linkInfo.inFrmCntr, 3);
   1368              *pBuf++ = LO_UINT16(pDev->linkInfo.txFailure);
   1369              *pBuf++ = HI_UINT16(pDev->linkInfo.txFailure);
   1370            }
   1371          }
   1372          
   1373          #if defined ZCL_KEY_ESTABLISH
   1374          /***************************************************************************************************
   1375           * @fn      MT_UtilzclGeneral_KeyEstablish_InitiateKeyEstablishment
   1376           *
   1377           * @brief   Proxy the zclGeneral_KeyEstablish_InitiateKeyEstablishment() function.
   1378           *
   1379           * @param   pBuf - pointer to the received buffer
   1380           *
   1381           * @return  void
   1382           ***************************************************************************************************/
   1383          static void MT_UtilzclGeneral_KeyEstablish_InitiateKeyEstablishment(uint8 *pBuf)
   1384          {
   1385            afAddrType_t partnerAddr;
   1386            uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
   1387            pBuf += MT_RPC_FRAME_HDR_SZ;
   1388          
   1389            partnerAddr.panId = 0;  // Not an inter-pan message.
   1390            partnerAddr.endPoint = pBuf[2];
   1391            partnerAddr.addrMode = (afAddrMode_t)pBuf[3];
   1392            if (afAddr64Bit == partnerAddr.addrMode)
   1393            {
   1394              (void)osal_memcpy(partnerAddr.addr.extAddr, pBuf+4, Z_EXTADDR_LEN);
   1395            }
   1396            else
   1397            {
   1398              partnerAddr.addr.shortAddr = BUILD_UINT16(pBuf[4], pBuf[5]);
   1399            }
   1400          
   1401            zcl_key_establish_task_id = pBuf[0];
   1402            *pBuf = zclGeneral_KeyEstablish_InitiateKeyEstablishment(MT_TaskID, &partnerAddr, pBuf[1]);
   1403            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, pBuf);
   1404          }
   1405          
   1406          /***************************************************************************************************
   1407           * @fn      MT_UtilzclGeneral_KeyEstablishment_ECDSASign
   1408           *
   1409           * @brief   Proxy the zclGeneral_KeyEstablishment_ECDSASign() function.
   1410           *
   1411           * @param   pBuf - pointer to the received buffer
   1412           *
   1413           * @return  void
   1414           ***************************************************************************************************/
   1415          static void MT_UtilzclGeneral_KeyEstablishment_ECDSASign(uint8 *pBuf)
   1416          {
   1417          #if defined TC_LINKKEY_JOIN
   1418            uint8 *output = osal_mem_alloc(SE_PROFILE_SIGNATURE_LENGTH+1);
   1419            uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
   1420            pBuf += MT_RPC_FRAME_HDR_SZ;
   1421          
   1422            if (NULL == output)
   1423            {
   1424              *pBuf = FAILURE;
   1425              MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, pBuf);
   1426            }
   1427            else
   1428            {
   1429              *output = zclGeneral_KeyEstablishment_ECDSASign(pBuf+1, *pBuf, output+1);
   1430              MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
   1431                                                   SE_PROFILE_SIGNATURE_LENGTH+1, output);
   1432              osal_mem_free(output);
   1433            }
   1434          #endif
   1435          }
   1436          
   1437          /***************************************************************************************************
   1438           * @fn      MT_UtilKeyEstablishInd
   1439           *
   1440           * @brief   Proxy the ZCL_KEY_ESTABLISH_IND command.
   1441           *
   1442           * @param   pInd - Pointer to a keyEstablishmentInd_t structure.
   1443           *
   1444           * @return  None
   1445           ***************************************************************************************************/
   1446          void MT_UtilKeyEstablishInd(keyEstablishmentInd_t *pInd)
   1447          {
   1448            uint8 msg[6];
   1449          
   1450            msg[0] = zcl_key_establish_task_id;
   1451            msg[1] = pInd->hdr.event;
   1452            msg[2] = pInd->hdr.status;
   1453            msg[3] = pInd->waitTime;
   1454            msg[4] = LO_UINT16(pInd->keyEstablishmentSuite);
   1455            msg[5] = HI_UINT16(pInd->keyEstablishmentSuite);
   1456          
   1457            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ | (uint8)MT_RPC_SYS_UTIL),
   1458                                                 MT_UTIL_ZCL_KEY_ESTABLISH_IND, 6, msg);
   1459          }
   1460          #endif
   1461          
   1462          /***************************************************************************************************
   1463           * @fn      MT_UtilSync
   1464           *
   1465           * @brief   Process the MT_UTIL_SYNC command
   1466           *
   1467           * @param   None
   1468           *
   1469           * @return  None
   1470           ***************************************************************************************************/
   1471          static void MT_UtilSync(void)
   1472          {
   1473           MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ|(uint8)MT_RPC_SYS_UTIL),MT_UTIL_SYNC_REQ,0,0);
   1474          }
   1475          #endif /* !defined NONWK */
   1476          #endif /* MT_UTIL_FUNC */
   1477          /**************************************************************************************************
   1478           **************************************************************************************************/


 
 
 0 bytes of memory

Errors: none
Warnings: none
