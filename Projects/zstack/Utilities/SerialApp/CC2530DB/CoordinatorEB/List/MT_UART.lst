###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.1.10194/W32 for 8051         12/Feb/2014  16:53:05 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  G:\ZStack-CC2530-V2.2\Components\mt\MT_UART.c      #
#    Command line       =  -f G:\ZStack-CC2530-V2.2\Projects\zstack\Utilities #
#                          \SerialApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoo #
#                          rd.cfg (-DCPU32MHZ -DROOT=__near_func              #
#                          -DMAC_CFG_APP_PENDING_QUEUE=TRUE                   #
#                          -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8         #
#                          -DMAC_CFG_RX_MAX=5 -DZDO_COORDINATOR -DRTR_NWK)    #
#                          -f G:\ZStack-CC2530-V2.2\Projects\zstack\Utilities #
#                          \SerialApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wCon #
#                          fig.cfg (-DZIGBEEPRO -DSECURE=0                    #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x04000000                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xfff1                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 G:\ZStack-CC2530-V2.2\Compo #
#                          nents\mt\MT_UART.c -D HAL_UART=TRUE -D             #
#                          SERIAL_APP_PORT=0 -D LCD_SUPPORTED -lC             #
#                          G:\ZStack-CC2530-V2.2\Projects\zstack\Utilities\Se #
#                          rialApp\CC2530DB\CoordinatorEB\List\ -lA           #
#                          G:\ZStack-CC2530-V2.2\Projects\zstack\Utilities\Se #
#                          rialApp\CC2530DB\CoordinatorEB\List\               #
#                          --diag_suppress Pe001,Pa010 -o                     #
#                          G:\ZStack-CC2530-V2.2\Projects\zstack\Utilities\Se #
#                          rialApp\CC2530DB\CoordinatorEB\Obj\ -e             #
#                          --no_code_motion --debug --core=plain --dptr=16,1  #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I G:\ZStack-CC2530-V2.2\Projects\zstack\Utilities #
#                          \SerialApp\CC2530DB\ -I G:\ZStack-CC2530-V2.2\Proj #
#                          ects\zstack\Utilities\SerialApp\CC2530DB\..\Source #
#                          \ -I G:\ZStack-CC2530-V2.2\Projects\zstack\Utiliti #
#                          es\SerialApp\CC2530DB\..\..\..\ZMain\TI2530DB\ -I  #
#                          G:\ZStack-CC2530-V2.2\Projects\zstack\Utilities\Se #
#                          rialApp\CC2530DB\..\..\..\..\..\Components\hal\inc #
#                          lude\ -I G:\ZStack-CC2530-V2.2\Projects\zstack\Uti #
#                          lities\SerialApp\CC2530DB\..\..\..\..\..\Component #
#                          s\hal\target\CC2530EB\ -I                          #
#                          G:\ZStack-CC2530-V2.2\Projects\zstack\Utilities\Se #
#                          rialApp\CC2530DB\..\..\..\..\..\Components\mac\inc #
#                          lude\ -I G:\ZStack-CC2530-V2.2\Projects\zstack\Uti #
#                          lities\SerialApp\CC2530DB\..\..\..\..\..\Component #
#                          s\mac\high_level\ -I G:\ZStack-CC2530-V2.2\Project #
#                          s\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\ #
#                          ..\Components\mac\low_level\srf04\ -I              #
#                          G:\ZStack-CC2530-V2.2\Projects\zstack\Utilities\Se #
#                          rialApp\CC2530DB\..\..\..\..\..\Components\mac\low #
#                          _level\srf04\single_chip\ -I                       #
#                          G:\ZStack-CC2530-V2.2\Projects\zstack\Utilities\Se #
#                          rialApp\CC2530DB\..\..\..\..\..\Components\mt\ -I  #
#                          G:\ZStack-CC2530-V2.2\Projects\zstack\Utilities\Se #
#                          rialApp\CC2530DB\..\..\..\..\..\Components\osal\in #
#                          clude\ -I G:\ZStack-CC2530-V2.2\Projects\zstack\Ut #
#                          ilities\SerialApp\CC2530DB\..\..\..\..\..\Componen #
#                          ts\services\saddr\ -I G:\ZStack-CC2530-V2.2\Projec #
#                          ts\zstack\Utilities\SerialApp\CC2530DB\..\..\..\.. #
#                          \..\Components\services\sdata\ -I                  #
#                          G:\ZStack-CC2530-V2.2\Projects\zstack\Utilities\Se #
#                          rialApp\CC2530DB\..\..\..\..\..\Components\stack\a #
#                          f\ -I G:\ZStack-CC2530-V2.2\Projects\zstack\Utilit #
#                          ies\SerialApp\CC2530DB\..\..\..\..\..\Components\s #
#                          tack\nwk\ -I G:\ZStack-CC2530-V2.2\Projects\zstack #
#                          \Utilities\SerialApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\stack\sapi\ -I G:\ZStack-CC2530-V2.2\Project #
#                          s\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\ #
#                          ..\Components\stack\sec\ -I                        #
#                          G:\ZStack-CC2530-V2.2\Projects\zstack\Utilities\Se #
#                          rialApp\CC2530DB\..\..\..\..\..\Components\stack\s #
#                          ys\ -I G:\ZStack-CC2530-V2.2\Projects\zstack\Utili #
#                          ties\SerialApp\CC2530DB\..\..\..\..\..\Components\ #
#                          stack\zdo\ -I G:\ZStack-CC2530-V2.2\Projects\zstac #
#                          k\Utilities\SerialApp\CC2530DB\..\..\..\..\..\Comp #
#                          onents\zmac\ -I G:\ZStack-CC2530-V2.2\Projects\zst #
#                          ack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\Co #
#                          mponents\zmac\f8w\ -Ohz --require_prototypes       #
#    List file          =  G:\ZStack-CC2530-V2.2\Projects\zstack\Utilities\Se #
#                          rialApp\CC2530DB\CoordinatorEB\List\MT_UART.lst    #
#    Object file        =  G:\ZStack-CC2530-V2.2\Projects\zstack\Utilities\Se #
#                          rialApp\CC2530DB\CoordinatorEB\Obj\MT_UART.r51     #
#                                                                             #
#                                                                             #
###############################################################################

G:\ZStack-CC2530-V2.2\Components\mt\MT_UART.c
      1          /***************************************************************************************************
      2            Filename:       MT_UART.c
      3            Revised:        $Date: 2009-03-12 16:25:22 -0700 (Thu, 12 Mar 2009) $
      4            Revision:       $Revision: 19404 $
      5          
      6            Description:  This module handles anything dealing with the serial port.
      7          
      8            Copyright 2007 Texas Instruments Incorporated. All rights reserved.
      9          
     10            IMPORTANT: Your use of this Software is limited to those specific rights
     11            granted under the terms of a software license agreement between the user
     12            who downloaded the software, his/her employer (which must be your employer)
     13            and Texas Instruments Incorporated (the "License").  You may not use this
     14            Software unless you agree to abide by the terms of the License. The License
     15            limits your use, and you acknowledge, that the Software may not be modified,
     16            copied or distributed unless embedded on a Texas Instruments microcontroller
     17            or used solely and exclusively in conjunction with a Texas Instruments radio
     18            frequency transceiver, which is integrated into your product.  Other than for
     19            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     20            works of, modify, distribute, perform, display or sell this Software and/or
     21            its documentation for any purpose.
     22          
     23            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     24            PROVIDED “AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     25            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     26            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     27            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     28            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     29            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     30            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     31            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     32            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     33            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     34          
     35            Should you have any questions regarding your right to use this Software,
     36            contact Texas Instruments Incorporated at www.TI.com.
     37          
     38          ***************************************************************************************************/
     39          
     40          /***************************************************************************************************
     41           * INCLUDES
     42           ***************************************************************************************************/
     43          #include "ZComDef.h"
     44          #include "OSAL.h"
     45          #include "hal_uart.h"
     46          #include "MT.h"
     47          #include "MT_UART.h"
     48          #include "OSAL_Memory.h"
     49          //#include "SAPP_Device.h"
     50          
     51          /***************************************************************************************************
     52           * MACROS
     53           ***************************************************************************************************/
     54          
     55          /***************************************************************************************************
     56           * CONSTANTS
     57           ***************************************************************************************************/
     58          /* State values for ZTool protocal */
     59          #define SOP_STATE      0x00
     60          #define LEN_STATE      0x01
     61          #define DATA_STATE     0x02
     62          #define FCS_STATE      0x03
     63          
     64          /***************************************************************************************************
     65           *                                         GLOBAL VARIABLES
     66           ***************************************************************************************************/
     67          /* Used to indentify the application ID for osal task */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     68          uint8 App_TaskID;
   \                     App_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     69          
     70          /* ZTool protocal parameters */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     71          uint8 state = SOP_STATE;
   \                     state:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     72          mtOSALSerialData_t  *pMsg;
   \                     pMsg:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     73          mtUserSerialMsg_t   *pMsgContent;
   \                     pMsgContent:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     74          uint8  tempDataLen;
   \                     tempDataLen:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     75          extern uint8 SendData(uint8 srcEP, const void *buf, uint16 addr, uint8 dstEP, uint8 Len);
     76          void RFIDprocess(uint8);  
     77          
     78          extern uint8 RfidStatus;
     79          extern uint8 rxBytePtr;
     80          extern uint8 rxByte[8];
     81          #if defined (ZAPP_P1) || defined (ZAPP_P2)
     82          uint16  MT_UartMaxZAppBufLen;
     83          bool    MT_UartZAppRxStatus;
     84          #endif
     85          
     86          
     87          /***************************************************************************************************
     88           *                                          LOCAL FUNCTIONS
     89           ***************************************************************************************************/
     90          
     91          /***************************************************************************************************
     92           * @fn      MT_UartInit
     93           *
     94           * @brief   Initialize MT with UART support
     95           *
     96           * @param   None
     97           *
     98           * @return  None
     99          ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    100          void MT_UartInit ()
   \                     MT_UartInit:
    101          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    102            halUARTCfg_t uartConfig;
    103          
    104            /* Initialize APP ID */
    105            App_TaskID = 0;
   \   000004   90....       MOV     DPTR,#App_TaskID
   \   000007   E4           CLR     A
   \   000008                REQUIRE ?Subroutine0
   \   000008                ; // Fall through to label ?Subroutine0
    106          
    107            /* UART Configuration */
    108            uartConfig.configured           = TRUE;
    109            uartConfig.baudRate             = MT_UART_DEFAULT_BAUDRATE;
    110            uartConfig.flowControl          = MT_UART_DEFAULT_OVERFLOW;
    111            uartConfig.flowControlThreshold = MT_UART_DEFAULT_THRESHOLD;
    112            uartConfig.rx.maxBufSize        = MT_UART_DEFAULT_MAX_RX_BUFF;
    113            uartConfig.tx.maxBufSize        = MT_UART_DEFAULT_MAX_TX_BUFF;
    114            uartConfig.idleTimeout          = MT_UART_DEFAULT_IDLE_TIMEOUT;
    115            uartConfig.intEnable            = TRUE;
    116          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    117            uartConfig.callBackFunc         = MT_UartProcessZToolData;
    118          #elif defined (ZAPP_P1) || defined (ZAPP_P2)
    119            uartConfig.callBackFunc         = MT_UartProcessZAppData;
    120          #else
    121            uartConfig.callBackFunc         = NULL;
    122          #endif
    123          
    124            /* Start UART */
    125          #if defined (MT_UART_DEFAULT_PORT)
    126            HalUARTOpen (MT_UART_DEFAULT_PORT, &uartConfig);
    127          #else
    128            /* Silence IAR compiler warning */
    129            (void)uartConfig;
    130          #endif
    131          
    132            /* Initialize for ZApp */
    133          #if defined (ZAPP_P1) || defined (ZAPP_P2)
    134            /* Default max bytes that ZAPP can take */
    135            MT_UartMaxZAppBufLen  = 1;
    136            MT_UartZAppRxStatus   = MT_UART_ZAPP_RX_READY;
    137          #endif
    138          
    139          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   D083         POP     DPH
   \   000003   D082         POP     DPL
   \   000005   02....       LJMP    ?BRET
    140          
    141          /***************************************************************************************************
    142           * @fn      MT_SerialRegisterTaskID
    143           *
    144           * @brief   This function registers the taskID of the application so it knows
    145           *          where to send the messages whent they come in.
    146           *
    147           * @param   void
    148           *
    149           * @return  void
    150           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    151          void MT_UartRegisterTaskID( byte taskID )
   \                     MT_UartRegisterTaskID:
    152          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    153            App_TaskID = taskID;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#App_TaskID
   \   000008   80..         SJMP    ?Subroutine0
    154          }
    155          
    156          /***************************************************************************************************
    157           * @fn      SPIMgr_CalcFCS
    158           *
    159           * @brief   Calculate the FCS of a message buffer by XOR'ing each byte.
    160           *          Remember to NOT include SOP and FCS fields, so start at the CMD field.
    161           *
    162           * @param   byte *msg_ptr - message pointer
    163           * @param   byte len - length (in bytes) of message
    164           *
    165           * @return  result byte
    166           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    167          byte MT_UartCalcFCS(uint8 lastResult, uint8 *msg_ptr, uint8 len )
   \                     MT_UartCalcFCS:
    168          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    169            uint8 x;
    170            uint8 xorResult = lastResult;
    171          
    172            for ( x = 0; x < len; x++, msg_ptr++ )
   \   000005   7800         MOV     R0,#0x0
   \   000007   800E         SJMP    ??MT_UartCalcFCS_0
    173              xorResult = xorResult ^ *msg_ptr;
   \                     ??MT_UartCalcFCS_1:
   \   000009   8A82         MOV     DPL,R2
   \   00000B   8B83         MOV     DPH,R3
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   C9           XCH     A,R1
   \   00000F   69           XRL     A,R1
   \   000010   F9           MOV     R1,A
   \   000011   08           INC     R0
   \   000012   A3           INC     DPTR
   \   000013   AA82         MOV     R2,DPL
   \   000015   AB83         MOV     R3,DPH
   \                     ??MT_UartCalcFCS_0:
   \   000017   E8           MOV     A,R0
   \   000018   C3           CLR     C
   \   000019   9C           SUBB    A,R4
   \   00001A   40ED         JC      ??MT_UartCalcFCS_1
    174          
    175            return ( xorResult );
   \   00001C   7F01         MOV     R7,#0x1
   \   00001E   02....       LJMP    ?BANKED_LEAVE_XDATA
    176          }

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_UartInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UartInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_UartRegisterTaskID?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UartRegisterTaskID

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_UartCalcFCS?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UartCalcFCS
    177          
    178          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    179          /***************************************************************************************************
    180           * @fn      MT_UartProcessZToolData
    181           *
    182           * @brief   | SOP | CMD |Data Length| cmdEP | Address | EndPoint |  Data  | FSC |
    183           *          |  1  |  2  |    1      |   2   |    2    |     1    | 1 ~119 |  1  |
    184           *
    185           *          Parses the data and determine either is SPI or just simply serial data
    186           *          then send the data to correct place (MT or APP)
    187           *
    188           * @param   port     - UART port
    189           *          event    - Event that causes the callback
    190           *
    191           *
    192           * @return  None
    193           ***************************************************************************************************/
    194          void MT_UartProcessZToolData ( uint8 port, uint8 event )
    195          {
    196              uint8  ch;
    197              uint8  bytesInRxBuffer;  
    198              
    199              (void)event;  // Intentionally unreferenced parameter
    200              
    201              while (Hal_UART_RxBufLen(port))
    202              {
    203                  HalUARTRead (port, &ch, 1);        
    204                  switch(state)
    205                  {
    206                  case SOP_STATE:
    207                      if(ch == MT_UART_SOF)
    208                          state = LEN_STATE;
    209                      break;
    210                  case LEN_STATE:
    211                      if(ch < 7)
    212                      {
    213                          // invalid length field
    214                          state = SOP_STATE;
    215                          break;
    216                      }
    217                      pMsg = (mtOSALSerialData_t *)osal_msg_allocate(sizeof(mtOSALSerialData_t) +
    218                                                                     ch + 3);//SOP+LEN+FSC
    219                      tempDataLen = 0;
    220                      /* Allocate memory for the data */
    221          //            pMsg = (mtOSALSerialData_t *)osal_msg_allocate(sizeof(mtOSALSerialData_t) + sizeof(mtUserSerialMsg_t) +
    222          //                                                           ch - 5);
    223                      if (pMsg)
    224                      {
    225                          /* Fill up what we can */
    226                          pMsg->hdr.event = CMD_SERIAL_MSG;
    227                          pMsg->msg = (uint8*)(pMsg + 1);
    228                          pMsgContent = (mtUserSerialMsg_t *)pMsg->msg;
    229                          pMsgContent->sop = MT_UART_SOF;
    230                          pMsgContent->len = ch;
    231                          state = DATA_STATE;
    232                      }
    233                      else
    234                      {
    235                          pMsgContent = NULL;
    236                          state = SOP_STATE;
    237                          return;
    238                      }
    239                      break;
    240                  case DATA_STATE:
    241                      pMsgContent->dataBody[tempDataLen++] = ch;
    242                      /* Check number of bytes left in the Rx buffer */
    243                      bytesInRxBuffer = Hal_UART_RxBufLen(port);
    244          
    245                      /* If the remain of the data is there, read them all, otherwise, just read enough */
    246                      if (bytesInRxBuffer <= pMsgContent->len - tempDataLen)
    247                      {
    248                          HalUARTRead (port, &pMsgContent->dataBody[tempDataLen], bytesInRxBuffer);
    249                          tempDataLen += bytesInRxBuffer;
    250                      }
    251                      else
    252                      {
    253                          HalUARTRead (port, &pMsgContent->dataBody[tempDataLen], pMsgContent->len - tempDataLen);
    254                          tempDataLen += (pMsgContent->len - tempDataLen);
    255                      }
    256                      /* If number of bytes read is equal to data length, time to move on to FCS */
    257                      if ( tempDataLen == pMsgContent->len )
    258                          state = FCS_STATE;
    259                      break;
    260                  case FCS_STATE:
    261                      /* Make sure it's correct */
    262                      {
    263                          pMsgContent->fsc = ch;
    264                          uint8 fcs = MT_UartCalcFCS(0, &pMsgContent->len, 1);
    265                          fcs = MT_UartCalcFCS(fcs, pMsgContent->dataBody, pMsgContent->len);
    266                          if(fcs == ch)
    267                              osal_msg_send(App_TaskID, (byte *)pMsg);
    268                          else
    269                              osal_msg_deallocate((uint8 *)pMsg);
    270                      }
    271                      /* Reset the state, send or discard the buffers at this point */
    272                      state = SOP_STATE;
    273                      break;
    274                  default:
    275                      break;
    276                  }
    277              }
    278          }
    279          #if 0
    280          void MT_UartProcessAppData ( uint8 port, uint8 event )
    281          {
    282             uint8  *bytesInRxBuffer;
    283            static uint8 *msg;
    284          
    285            (void)event;  // Intentionally unreferenced parameter
    286            msg = (uint8 *)osal_msg_allocate(5);
    287            if(msg){
    288              bytesInRxBuffer = msg;
    289              *bytesInRxBuffer ++ = CMD_SERIAL_MSG;
    290            }
    291            while (Hal_UART_RxBufLen(port))
    292            {
    293              HalUARTRead (port, bytesInRxBuffer , 5);
    294              osal_msg_send( App_TaskID, (byte *)msg );
    295            }
    296          }
    297          #endif
    298          
    299          #endif
    300          #if defined (ZAPP_P1) || defined (ZAPP_P2)
    301          /***************************************************************************************************
    302           * @fn      MT_UartProcessZAppData
    303           *
    304           * @brief   | SOP | CMD  |   Data Length   | FSC  |
    305           *          |  1  |  2   |       1         |  1   |
    306           *
    307           *          Parses the data and determine either is SPI or just simply serial data
    308           *          then send the data to correct place (MT or APP)
    309           *
    310           * @param   port    - UART port
    311           *          event   - Event that causes the callback
    312           *
    313           *
    314           * @return  None
    315           ***************************************************************************************************/
    316          void MT_UartProcessZAppData ( uint8 port, uint8 event )
    317          {
    318          
    319            osal_event_hdr_t  *msg_ptr;
    320            uint16 length = 0;
    321            uint16 rxBufLen  = Hal_UART_RxBufLen(MT_UART_DEFAULT_PORT);
    322          
    323            /*
    324               If maxZAppBufferLength is 0 or larger than current length
    325               the entire length of the current buffer is returned.
    326            */
    327            if ((MT_UartMaxZAppBufLen != 0) && (MT_UartMaxZAppBufLen <= rxBufLen))
    328            {
    329              length = MT_UartMaxZAppBufLen;
    330            }
    331            else
    332            {
    333              length = rxBufLen;
    334            }
    335          
    336            /* Verify events */
    337            if (event == HAL_UART_TX_FULL)
    338            {
    339              // Do something when TX if full
    340              return;
    341            }
    342          
    343            if (event & ( HAL_UART_RX_FULL | HAL_UART_RX_ABOUT_FULL | HAL_UART_RX_TIMEOUT))
    344            {
    345              if ( App_TaskID )
    346              {
    347                /*
    348                   If Application is ready to receive and there is something
    349                   in the Rx buffer then send it up
    350                */
    351                if ((MT_UartZAppRxStatus == MT_UART_ZAPP_RX_READY ) && (length != 0))
    352                {
    353                  /* Disable App flow control until it processes the current data */
    354                   MT_UartAppFlowControl (MT_UART_ZAPP_RX_NOT_READY);
    355          
    356                  /* 2 more bytes are added, 1 for CMD type, other for length */
    357                  msg_ptr = (osal_event_hdr_t *)osal_msg_allocate( length + sizeof(osal_event_hdr_t) );
    358                  if ( msg_ptr )
    359                  {
    360                    msg_ptr->event = SPI_INCOMING_ZAPP_DATA;
    361                    msg_ptr->status = length;
    362          
    363                    /* Read the data of Rx buffer */
    364                    HalUARTRead( MT_UART_DEFAULT_PORT, (uint8 *)(msg_ptr + 1), length );
    365          
    366                    /* Send the raw data to application...or where ever */
    367                    osal_msg_send( App_TaskID, (uint8 *)msg_ptr );
    368                  }
    369                }
    370              }
    371            }
    372          }
    373          
    374          /***************************************************************************************************
    375           * @fn      SPIMgr_ZAppBufferLengthRegister
    376           *
    377           * @brief
    378           *
    379           * @param   maxLen - Max Length that the application wants at a time
    380           *
    381           * @return  None
    382           *
    383           ***************************************************************************************************/
    384          void MT_UartZAppBufferLengthRegister ( uint16 maxLen )
    385          {
    386            /* If the maxLen is larger than the RX buff, something is not right */
    387            if (maxLen <= MT_UART_DEFAULT_MAX_RX_BUFF)
    388              MT_UartMaxZAppBufLen = maxLen;
    389            else
    390              MT_UartMaxZAppBufLen = 1; /* default is 1 byte */
    391          }
    392          
    393          /***************************************************************************************************
    394           * @fn      SPIMgr_AppFlowControl
    395           *
    396           * @brief
    397           *
    398           * @param   status - ready to send or not
    399           *
    400           * @return  None
    401           *
    402           ***************************************************************************************************/
    403          void MT_UartAppFlowControl ( bool status )
    404          {
    405          
    406            /* Make sure only update if needed */
    407            if (status != MT_UartZAppRxStatus )
    408            {
    409              MT_UartZAppRxStatus = status;
    410            }
    411          
    412            /* App is ready to read again, ProcessZAppData have to be triggered too */
    413            if (status == MT_UART_ZAPP_RX_READY)
    414            {
    415              MT_UartProcessZAppData (MT_UART_DEFAULT_PORT, HAL_UART_RX_TIMEOUT );
    416            }
    417          }
    418          #endif //ZAPP
    419          /***************************************************************************************************/

   Maximum stack usage in bytes:

     Function              ISTACK PSTACK XSTACK
     --------              ------ ------ ------
     MT_UartCalcFCS            0      0      9
     MT_UartInit               2      0      0
     MT_UartRegisterTaskID     2      0      0


   Segment part sizes:

     Function/Label                Bytes
     --------------                -----
     App_TaskID                       1
     state                            1
     pMsg                             2
     pMsgContent                      2
     tempDataLen                      1
     MT_UartInit                      8
     ?Subroutine0                     8
     MT_UartRegisterTaskID           10
     MT_UartCalcFCS                  33
     ??MT_UartInit?relay              6
     ??MT_UartRegisterTaskID?relay    6
     ??MT_UartCalcFCS?relay           6

 
 59 bytes in segment BANKED_CODE
 18 bytes in segment BANK_RELAYS
  7 bytes in segment XDATA_Z
 
 77 bytes of CODE  memory
  7 bytes of XDATA memory

Errors: none
Warnings: none
